/* 
This file was generated by Dashcode. You may edit this file to customize your widget or web page 
according to the license.txt file included in the project.

The remote widget was originally designed/created for Boxee (and later also Plex) by Lot49 (lot49.org).
This XBMC version was modified by Topfjoer; more or less rewritten since Frodo. ;-)
*/

// Global variables and connection:
//
document.onkeydown = KeyCheck;
document.onpaste = Paste;
var keyboard = 0; //Variable for detection of virtual keyboard
var connection = new Object();

// Try to connect to XBMC's Remote connection server:
function connect() {
    var hostvalue = document.getElementById('host').value;
    var portvalue = document.getElementById('portxbmc').value;
    var url = 'ws://' + hostvalue + ':'+portvalue+'/jsonrpc';   
    connection = new WebSocket(url);     
}

// Closes any existing connections:
function disconnect() {
    if (connection.readyState==1) {
        //window.alert("Closed!");
        connection.close();
    };
}

// Function: load(); Called by HTML body element's onload event when the widget is ready to start
function load() {
    dashcode.setupParts();
    if (widget.preferenceForKey('hostkey') && widget.preferenceForKey('portkeyxbmc')) {load_preferences();};
}

// Function: remove(); Called when the widget has been removed from the Dashboard
function remove() {
    // Stop any timers to prevent CPU usage
    // Remove any preferences as needed
    // widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
}

// Function: hide(); Called when the widget has been hidden
function hide() {
    // Stop any timers to prevent CPU usage
}

// Function: show(); Called when the widget has been shown
function show() {
    // Restart any timers that were stopped on hide
}

// Function: sync(); Called when the widget has been synchronized with .Mac
function sync() {
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

if (window.widget) {
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}

// Function linked to info button. Event = onclick; reveals back pane.
function showBack(event) {
    var front = document.getElementById('front');
    var back = document.getElementById('back');
    if (window.widget) {
        widget.prepareForTransition('ToBack');
    }
    front.style.display = 'none';
    back.style.display = 'block';
    if (window.widget) {
        setTimeout('widget.performTransition();', 100);
    }
    keyboard=2;
}

// Show panes for text input or settings:
function showpane(cur,nxt) {
    var current = document.getElementById(cur);
    var next = document.getElementById(nxt);
    if (cur=='front') {
        widget.prepareForTransition('ToBack');
    }
    else {
        widget.prepareForTransition('ToFront');
    }
    current.style.display = 'none';
    next.style.display = 'block';
    if (window.widget) {setTimeout('widget.performTransition();', 100);}
}

// Functions for saving and loading settings:
function save_preferences() {
    var HostKey = 'hostkey';        
    var PortKeyXBMC = 'portkeyxbmc';
    var PortKeySSH = 'portkeyssh';
    var UserKey = 'userkey';
    var PassKey = 'passkey';
    var host_value = preferences_pane.host.value;
    var portxbmc_value = preferences_pane.portxbmc.value;
    var portssh_value = preferences_pane.portssh.value;
    var user_value = preferences_pane.user.value;
    var pass_value = preferences_pane.pass.value;
    widget.setPreferenceForKey(host_value, HostKey);
    widget.setPreferenceForKey(portxbmc_value, PortKeyXBMC);
    widget.setPreferenceForKey(portssh_value, PortKeySSH);
    widget.setPreferenceForKey(user_value, UserKey);
    widget.setPreferenceForKey(pass_value, PassKey);
    setLogo();
}

function load_preferences() {
    preferences_pane.host.value = widget.preferenceForKey('hostkey');
    preferences_pane.portxbmc.value = widget.preferenceForKey('portkeyxbmc');
    preferences_pane.portssh.value = widget.preferenceForKey('portkeyssh');
    preferences_pane.user.value = widget.preferenceForKey('userkey');
    preferences_pane.pass.value = widget.preferenceForKey('passkey');
    setLogo();
}

function setLogo() {
    if (widget.preferenceForKey('portkeyssh')=='' || widget.preferenceForKey('userkey')=='' || widget.preferenceForKey('passkey')=='') {
        document.getElementById('logo').setAttribute('class', 'logo');
    }
    else {
        document.getElementById('logo').setAttribute('class', 'start');
    };
}

// Start XBMC using expect:
function StartXBMC() {
    var hostvalue = widget.preferenceForKey('hostkey');
    var portsshvalue = widget.preferenceForKey('portkeyssh');
    var uservalue = widget.preferenceForKey('userkey');
    var passvalue = widget.preferenceForKey('passkey');
    var command = '/usr/bin/expect -c "spawn ssh -p'+portsshvalue+' '+uservalue+'@'+hostvalue+'; expect password:; send '+passvalue+
                        '\\r; send screen\\ -d\\ -m\\ xinit\\ xbmc\\r; expect xorg.conf.d; send \\001; send d; send exit\\r"';
    widget.system(command, null);
}


// Construct (batch-)request:
function Remote(method1,params1,method2,params2,method3,params3) {  
    var request = buildreq(method1,params1);
    if (method2) {request = request+','+buildreq(method2,params2);};
    if (method3) {request = request+','+buildreq(method3,params3);};
    if (method2) {request = '['+request+']';};
    //window.alert(request);
    if (connection.readyState==1) {
        sendreq(request);
    } 
    else {
        connect();
        connection.onopen = function() {sendreq(request);}; 
    };
} 

// Construct single request:
function buildreq(method,params) {
    var request;
    switch (method) {
        case 'Input.SendText':
            request = '{"jsonrpc":"2.0","method":"'+method+'","params":{"text":'+JSON.stringify(document.getElementById('sendtext').value)+'},"id":1}';
            break;
        case 'Input.ExecuteAction':
            request = '{"jsonrpc":"2.0","method":"'+method+'","params":{"action":"'+params+'"},"id":1}';
            break;
        case 'Playlist.Clear': // Clear video playlist:
            request = '{"jsonrpc":"2.0","method":"Playlist.Clear","params":{"playlistid":1},"id":1}';
            break;
        case 'Playlist.Add': // Add YouTube-link to video playlist:
            request = '{"jsonrpc":"2.0","method":"'+method+'","params":{"playlistid":1,"item":{"file":"'+params+'"}},"id":1}';
            break;
        case 'Player.Open': // Start player:
            if (params) {
                request = '{"jsonrpc":"2.0","method":"'+method+'","params":{"item":{"file":"'+params+'"}},"id":1}';
                }
            else {
                request = '{"jsonrpc":"2.0","method":"Player.Open","params":{"item":{"playlistid":1}},"id":1}';
                };
            break;
        default:
            request = '{"jsonrpc":"2.0","method":"'+method+'","id":1}';
    };
    return(request);
}

// Send request to XBMC's remote server:
function sendreq(request) {
    connection.send(request);
    connection.onmessage = function(msg) { 
        //window.alert(msg.data);
        var messages = JSON.parse(msg.data);
        if (messages.method=='Input.OnInputRequested' && keyboard!=1) {
            document.getElementById('sendtext').value = messages.params.data.value;
            showpane('front','textinput'); 
            keyboard = 1;
        };
        if (messages.method=='Input.OnInputFinished' && keyboard!=0) {
            showpane('textinput','front'); 
            keyboard = 0;
        };
    };
    connection.onclose = function () {
        disconnect();
    };
}

// Translates keycode to remote action:
function KeyCheck(event) { 
    var KeyID = event.keyCode;
    if (keyboard==1) {
        switch(KeyID) {
            case 13:
                showpane('textinput','front'); keyboard = 0; Remote('Input.SendText'); // Select (Enter)
                break;
        };
    }
    else if (keyboard==2) {
        switch(KeyID) {
            case 13:
                showpane('back','front'); keyboard = 0; save_preferences(); disconnect(); // Select (Enter)
                break;
        };
    
    }
    else {
        switch(KeyID) {
        // Main navigation keys:
            case 13:
                Remote('Input.Select'); // Select (Enter)
                break;
            case 37:
                ShiftFunc('stepback','Input.Left'); // Left
                break;
            case 38:
                ShiftFunc('bigstepforward','Input.Up'); // Up 
                break;
            case 39:
                ShiftFunc('stepforward','Input.Right'); // Right
                break;
            case 40:
                ShiftFunc('bigstepback','Input.Down'); // Down
                break; 
            case 8:
                Remote('Input.ExecuteAction','back'); // Back (Backspace)
                break;
            case 27:
                Remote('Input.Home'); // Home (Esc)
                break;
            case 72:
                Remote('Input.Home'); // Home (h)
                break;
            case 9:
                Remote('Input.ExecuteAction','fullscreen'); // Fullscreen (Tab)
                break;
            case 70:
                Remote('Input.ExecuteAction','fullscreen'); // Fullscreen (f)
                break;
            case 46:
                Remote('Application.Quit'); // Exit XBMC
                break;         
        // Play content:
            case 32:
                Remote('Input.ExecuteAction','pause'); // Play-Pause (Space)
                break;        
            case 88:
                Remote('Input.ExecuteAction','stop'); // Stop (x)
                break;  
            case 83:
                Remote('Input.ExecuteAction','stop'); // Stop (s)
                break;            
            case 190:
                Remote('Input.ExecuteAction','fastforward'); // SkipNext (.)
                break;            
            case 188:
                Remote('Input.ExecuteAction','rewind'); // SkipPrevious (,)
                break;  
            case 187:
                Remote('Input.ExecuteAction','skipnext'); // SkipNext (-)
                break;            
            case 189:
                Remote('Input.ExecuteAction','skipprevious'); // SkipPrevious (=)
                break;    
        // Player info:
            case 77:
                Remote('Input.ShowOSD'); // OSD menu (m)
                break;
            case 67:
                Remote('Input.ExecuteAction','contextmenu'); // Contextmenu (c)
                break;        
            case 73:
                Remote('Input.Info'); // Info (i)
                break;
            case 79:
                Remote('Input.ShowCodec'); // ShowCodec (o)
                break;
            case 76:
                Remote('Input.ExecuteAction','playlist'); // Playlist (l)
                break; 
            case 80:
                Remote('Input.ExecuteAction','playlist'); // Playlist (p)
                break;        
            case 81:
                Remote('Input.ExecuteAction','queue'); // Queue (q)
                break;
        // Volume:                
            case 220:
                Remote('Input.ExecuteAction','mute'); // Mute (\)
                break;        
            case 221:
                Remote('Input.ExecuteAction','volumeup'); // + Volume (])
                break;        
            case 219:
                Remote('Input.ExecuteAction','volumedown'); // - Volume ([)
                break;
        };
    };
}

// Shift function for arrow keys:
function ShiftFunc(action1, action2) {
    if (event.shiftKey) {Remote('Input.ExecuteAction',action1);}
    else {Remote(action2);};
}

// Functions for sending YouTube link:
// Drop a link:
function Drop(event) {
    var url = event.dataTransfer.getData('text/uri-list').split(/[?]/);
    makelink(url);
    event.stopPropagation();
	event.preventDefault();
}
// Cancel drag events:
function Drag(event) {
	event.stopPropagation();
	event.preventDefault();
}

// Paste a link:
function Paste(event) {
    var url = event.clipboardData.getData('text').split(/[?]/);
    makelink(url);
}

// Detect link type:
function linkType(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length)!==-1;
}

// Extract video- or playlist-id and send to remote function:
function makelink(url) {
    var yt = url[0].search('youtube');
    var urlv = linkType(url[0],'watch');
    var urlp = linkType(url[0],'playlist');   
    var urlid = new Array();
    try {urlid = url[1].split(/[=&]/);} catch (e) {};
    var notify = document.getElementById('notify');
    //window.alert(urlv);
    if (yt!=-1 && urlv==true && urlid[1]) {
        Remote('Playlist.Clear','','Playlist.Add','plugin://plugin.video.youtube/?action=play_video&videoid='+urlid[1],'Player.Open','');
    }
    else if (yt!=-1 && urlp==true && urlid[1]) {
        Remote('Player.Open','plugin://plugin.video.youtube/?path=/root/playlists&action=play_all&playlist='+urlid[1]);
        
    } 
    else {
        notify.style.display = 'block'; setTimeout('notify.style.display = "none";', 2000);
    };
}
